I"ü<p>Cross-validation is a pretty cool method to compare different models that you‚Äôre trying to fit your data to, and see which models are yield the most robust results. This inherently means that the most robust models are the least prone to find themselves overfitting to your data.</p>

<hr />
<hr />

<h1 id="theory">Theory</h1>
<h2 id="types">Types</h2>
<h3 id="leave-one-out-cross-validation">Leave-One-Out Cross-Validation</h3>
<h3 id="leave-p-out-cross-validation">Leave-p-Out Cross-Validation</h3>
<h3 id="k-fold-cross-validation">k-Fold Cross-validation</h3>

<hr />
<hr />

<h1 id="examples">Examples</h1>
<p>So here are two examples of using it. For these examples, we will be comparing different polynomial orders, e.g.</p>

\[y = \beta_0 + \beta_1 x_1\]

\[y = \beta_0 + \beta_1 x + \beta_2 x^2\]

\[y = \beta_0 + \beta_1 x + \beta_2 x^2 + \cdots + \beta_k x^k\]

<p>and we will be using the <a href="http://nicolasshu.com/math/2018/05/17/matherrors.html">mean squared error</a> to quantify our errors.</p>

<hr />

<h2 id="big-picture-first">Big Picture First</h2>
<h3 id="import-the-libraries">Import the Libraries</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>
<h3 id="set-the-highest-order-to-be-used">Set the Highest Order to be used</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">high_order</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">polyOrders</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">high_order</span><span class="p">))</span>
</code></pre></div></div>
<h3 id="generate-the-numbers">Generate the Numbers</h3>
<p>We will first set a number of datapoint \(N\), and for this case, I just decided to have</p>

\[\vec{y} = \vec{y_1} + \vec{y_2} + \vec{y_3} + \vec{y_4} \quad \text{ where}\]

\[\begin{cases}
\vec{y_1} = \vec{x} + \text{randomness} \\
\vec{y_2} = \vec{x}^2 + \text{randomness} \\
\vec{y_3} = \vec{x}^3 + \text{randomness} \\
\vec{y_4} = 30 \sin(\vec{x}) + \text{randomness} \\
\end{cases}\]

<p>because why not?</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="n">rand_mag</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">y1</span> <span class="o">=</span> <span class="n">x</span>      <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">rand_mag</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">rand_mag</span>
<span class="n">y3</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span>   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">rand_mag</span>
<span class="n">y4</span> <span class="o">=</span> <span class="mi">30</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">rand_mag</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">y2</span><span class="o">+</span><span class="n">y3</span><span class="o">+</span><span class="n">y4</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
</code></pre></div></div>

<p>When plotting it, we <strong>MAY</strong> have the following data (don‚Äôt forget that there is a randomness that I added to it)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">'bo'</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'Random Numbers'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>
</code></pre></div></div>

<p>[INSERT FIGURE]</p>

<h3 id="whats-our-main-question">What‚Äôs our main question?</h3>
<p>So, the question is,</p>

<p>And we can fit it to a polynomial by using <code class="language-plaintext highlighter-rouge">numpy.polyfit()</code>, e.g.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ORDER</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">coeffs2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ORDER</span><span class="p">)</span>
<span class="n">polyFn2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coeffs2</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">'bo'</span><span class="p">);</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">polyFn2</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s">'r-'</span><span class="p">)</span>
</code></pre></div></div>

<p>[INSERT FIGURE]</p>

<p>But the question is:<br />
<strong>We can fit multiple different polynomial order models to our data, but which one is the best? How can we decide it?</strong></p>

<p>[INSERT MULTIPLE FIGURES - 6 orders in 2x3 or 3x2 fashion]</p>

<p>Below we will see only two types of cross-validation being applied</p>

<hr />

<h2 id="leave-one-out-cross-validation-loocv">Leave-One-Out Cross-Validation (LOOCV)</h2>
<p>As explained above, the Leave-One-Out method looks at every possibility when you remove a single datapoint, train the model on the \(N-1\) datapoints, and then see how the robust is the model towards that datapoint</p>

<p><em>Again, these scripts may not be the most efficient ways of doing cross-validation, but it‚Äôs to lay a good framework of how it works</em></p>

<h3 id="initiate-the-results">Initiate the Results</h3>
<p>We can first create a <code class="language-plaintext highlighter-rouge">results</code> array, where we will store the results. This array will be in \(\mathbb{R}^{\text{Number of Orders} \times N}\), where \(N\) is the number of datapoints</p>

<h3 id="validate-it-for-every-datapoint">Validate it for Every Datapoint</h3>
<p>So as stated before, we‚Äôre going to iterate through every datapoint, and for each datapoint, we‚Äôre going to remove it, and train the model based on the rest.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1"># PARTIAL
</span>        <span class="c1"># Remove this datapoint
</span>        <span class="n">x_mod</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">iter</span><span class="p">)</span>
        <span class="n">y_mod</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="nb">iter</span><span class="p">)</span>

        <span class="c1"># Train the model
</span>        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x_mod</span><span class="p">,</span><span class="n">y_mod</span><span class="p">,</span><span class="n">order</span><span class="p">)</span>
        <span class="n">polyFn</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
</code></pre></div></div>

<p>We will then predict the labels \(y_{pred}\), and then, by using the <a href="http://nicolasshu.com/math/2018/05/17/matherrors.html">mean squared error</a> (we will first compute the squared residual, and later on take the mean)</p>

\[Residual^2 = (y_{true} - y_{pred})^2\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1"># PARTIAL
</span>        <span class="c1"># Predict the results
</span>        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">polyFn</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
        <span class="n">y_true</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span>

        <span class="c1"># Get the residual squared on that single data point that was excluded
</span>        <span class="n">thisError</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</code></pre></div></div>

<p>Then we will store that \(residual^2\) on the <code class="language-plaintext highlighter-rouge">results</code> array, and we can plot it for funsies too</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1"># PARTIAL
</span>        <span class="c1"># Store on Results
</span>        <span class="n">results</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="nb">iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisError</span>

        <span class="c1"># (OPTIONAL) Plot those predictions
</span>        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">polyFn</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s">'r-'</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'Predicted Points'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="iterate-through-different-polynomial-orders">Iterate through different polynomial orders</h3>
<p>All there is left to do is to let it iterate it through different orders</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">high_order</span><span class="p">):</span>
</code></pre></div></div>

<h3 id="complete-validation-of-every-point-for-every-polynomial-order">Complete Validation of Every Point for Every Polynomial Order</h3>
<p>Your complete cross-validation will be the following:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">high_order</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

<span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">high_order</span><span class="p">):</span>
    <span class="c1"># For each polynomial order...
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">'bo'</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'Modified Points'</span><span class="p">)</span>

    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="c1"># For every data point...
</span>
        <span class="c1"># Remove this datapoint
</span>        <span class="n">x_mod</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">iter</span><span class="p">)</span>
        <span class="n">y_mod</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="nb">iter</span><span class="p">)</span>

        <span class="c1"># Train the model
</span>        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x_mod</span><span class="p">,</span><span class="n">y_mod</span><span class="p">,</span><span class="n">order</span><span class="p">)</span>
        <span class="n">polyFn</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>

        <span class="c1"># Predict the results
</span>        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">polyFn</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
        <span class="n">y_true</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span>

        <span class="c1"># Get the residual squared on that single data point that was excluded
</span>        <span class="n">thisError</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Store on Results
</span>        <span class="n">results</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="nb">iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisError</span>

        <span class="c1"># Plot those predictions
</span>        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">polyFn</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s">'r-'</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'Predicted Points'</span><span class="p">)</span>
        <span class="c1">#plt.plot(x[iter],y[iter],'g*',markersize=20,label='Removed Point')
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">);</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">);</span> <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Polynomial (Order = %d)'</span> <span class="o">%</span> <span class="n">order</span><span class="p">)</span>
</code></pre></div></div>

<p>[INSERT A FEW OF THE FIGURES 3x2 or 2x3]</p>

<h3 id="show-your-results">Show Your Results</h3>
<p>All you have to do left is to plot your results. Here, remember how I didn‚Äôt compute the mean of the MSE? I am now going to compute that mean</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Remove zeroth order
</span><span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#Calculate Estimated Prediction Error
</span><span class="n">PE</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Show the Estimated Mean Prediction Errors for Each Polynomial
</span><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">PE</span><span class="p">,</span><span class="s">'bo-'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Polynomial Order'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Estimated Mean Prediction Error'</span><span class="p">)</span>
</code></pre></div></div>

<p>[INSERT THAT LAST FIGURE!]</p>

<hr />

<h2 id="k-fold-cross-validation-1">k-Fold Cross-validation</h2>

<p>As explained above, the k-Fold cross validation requires one to separate your data into k parts, which may be randomized or not, remove one of the parts, train the data on the rest, and iterate through the different parts.</p>

<p>To do so, you can choose to build your partitioning algorithm from scratch (I highly suggest it as it cranks out your coding kung fu), or you can use <a href="http://scikit-learn.org/stable/index.html">SciKit Learn</a>‚Äôs <a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html"><code class="language-plaintext highlighter-rouge">KFold</code></a></p>

<h3 id="import-that-function">Import that Function</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">KFold</span>
</code></pre></div></div>

<h3 id="initialize-some-constants">Initialize Some Constants</h3>
<p>In this case, I‚Äôm setting that I‚Äôll repeat the experiment for 20 rounds, and I would like to partition the data into 5 parts. I am also initializing a list <code class="language-plaintext highlighter-rouge">results_list</code>, where I‚Äôll store my results</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rounds</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">K</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">results_list</span> <span class="o">=</span> <span class="p">[]</span>               <span class="c1"># Each element will be for one round
</span></code></pre></div></div>

<h3 id="start-up-the-kfold-class">Start Up the KFold Class</h3>
<p>So, we gotta start up our KFold class, to start to use its set of tools, and then we can split up our data, which is stored in <code class="language-plaintext highlighter-rouge">x</code></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># Initiate the KFold Class
</span>    <span class="n">kf</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># Separate Data into K parts
</span>    <span class="n">kf</span><span class="p">.</span><span class="n">get_n_splits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>If you‚Äôd like to get some of the status, we can write</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">kf</span>
<span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="start-validating-your-partsfolds">Start Validating Your Parts/Folds</h3>
<p>For each experiment (i.e <code class="language-plaintext highlighter-rouge">round</code>), we will use an array <code class="language-plaintext highlighter-rouge">results</code> to get the validation results.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">high_order</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>
</code></pre></div></div>

<p>For each part/fold, we will separate the data into the training set (<code class="language-plaintext highlighter-rouge">x_train</code>, <code class="language-plaintext highlighter-rouge">y_train</code>) and testing set (<code class="language-plaintext highlighter-rouge">x_test</code>, <code class="language-plaintext highlighter-rouge">y_test</code>)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># PARTIAL
</span>    <span class="k">for</span> <span class="nb">iter</span><span class="p">,</span> <span class="p">(</span><span class="n">train_index</span><span class="p">,</span> <span class="n">test_index</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kf</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="c1"># For each split...
</span>        <span class="c1"># Now we have the indices for the training set and the test set
</span>        <span class="n">x_train</span><span class="p">,</span> <span class="n">x_test</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>
        <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>
</code></pre></div></div>

<p>in which we can plot it for funsies</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1"># PARTIAL
</span>        <span class="c1"># Plot the training set and the test set together
</span>        <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">,</span><span class="s">'bo'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span><span class="n">y_test</span><span class="p">,</span><span class="s">'rx'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">);</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>
</code></pre></div></div>

<p>Now for each polynomial order, we can train the model, and create a polynomial function</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1"># PARTIAL
</span>        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">high_order</span><span class="p">):</span>
            <span class="c1"># For each polynomial order...
</span>            <span class="c1"># Train the model based on the training set and create a polynomial function
</span>            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">,</span> <span class="n">order</span> <span class="p">)</span>
            <span class="n">polyFn</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, we calculate the predictions \(y_{pred}\), and we can calculate the mean squared error based on the residuals, and we can store that onto the <code class="language-plaintext highlighter-rouge">results</code> (numpy array).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="c1"># Calculate the predictions
</span>            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">polyFn</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

            <span class="c1"># Calculate the estimated prediction error
</span>            <span class="n">thisError</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">((</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Store on Results
</span>            <span class="n">results</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="nb">iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisError</span>
</code></pre></div></div>

<p>Remember, the way that we are storing things is, if we had 3 parts/folds and were testing on two polynomial orders</p>

\[y = \beta_0 + \beta_1 x_1\]

\[y = \beta_0 + \beta_1 x + \beta_2 x^2\]

<p><img src="https://g.gravizo.com/svg? digraph G {      &quot;y_pred \n (Order 1 \n Fold 1)&quot; -&gt; &quot;thisError \n (Order 1 \n Fold 1)&quot; [label=&quot;MSE w/ \n y_test&quot;]      &quot;y_pred \n (Order 1 \n Fold 2)&quot; -&gt; &quot;thisError \n (Order 1 \n Fold 2)&quot; [label=&quot;MSE w/ \n y_test&quot;]      &quot;y_pred \n (Order 1 \n Fold 3)&quot; -&gt; &quot;thisError \n (Order 1 \n Fold 3)&quot; [label=&quot;MSE w/ \n y_test&quot;]      &quot;y_pred \n (Order 2 \n Fold 1)&quot; -&gt; &quot;thisError \n (Order 2 \n Fold 1)&quot; [label=&quot;MSE w/ \n y_test&quot;]      &quot;y_pred \n (Order 2 \n Fold 2)&quot; -&gt; &quot;thisError \n (Order 2 \n Fold 2)&quot; [label=&quot;MSE w/ \n y_test&quot;]      &quot;y_pred \n (Order 2 \n Fold 3)&quot; -&gt; &quot;thisError \n (Order 2 \n Fold 3)&quot; [label=&quot;MSE w/ \n y_test&quot;]     &quot;thisError \n (Order 1 \n Fold 1)&quot; -&gt; &quot;results \n Order 1&quot;     &quot;thisError \n (Order 1 \n Fold 2)&quot; -&gt; &quot;results \n Order 1&quot;     &quot;thisError \n (Order 1 \n Fold 3)&quot; -&gt; &quot;results \n Order 1&quot;     &quot;thisError \n (Order 2 \n Fold 1)&quot; -&gt; &quot;results \n Order 2&quot;     &quot;thisError \n (Order 2 \n Fold 2)&quot; -&gt; &quot;results \n Order 2&quot;     &quot;thisError \n (Order 2 \n Fold 3)&quot; -&gt; &quot;results \n Order 2&quot;     &quot;results \n Order 1&quot; -&gt; &quot;thisResult \n Order 1&quot; [label=&quot; Average&quot;]     &quot;results \n Order 2&quot; -&gt; &quot;thisResult \n Order 2&quot; [label=&quot; Average&quot;]     &quot;thisResult \n Order 2&quot; -&gt; results_list     &quot;thisResult \n Order 1&quot; -&gt; results_list } " /></p>

<p>All there‚Äôs left to do is to store it onto the <code class="language-plaintext highlighter-rouge">results_list</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># PARTIAL
</span>    <span class="c1"># Put it on the list!
</span>    <span class="n">results_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisResult</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="complete-validation">Complete Validation</h3>
<p>Your complete validation for the K-Fold CV will be now iterating through different experiments (i.e. <code class="language-plaintext highlighter-rouge">rounds</code>), where in each experiment, you pull out some random elements, validate it, then in the next experiment, you put everything back into that bag, shake it, and repeat.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">KFold</span>
<span class="n">rounds</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">K</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">results_list</span> <span class="o">=</span> <span class="p">[]</span>               <span class="c1"># Each element will be for one round
</span><span class="k">for</span> <span class="nb">round</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rounds</span><span class="p">):</span>
    <span class="c1"># For each round of results...
</span>    <span class="c1"># Initiate the KFold Class
</span>    <span class="n">kf</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># Separate Data into K parts
</span>    <span class="n">kf</span><span class="p">.</span><span class="n">get_n_splits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># To get status
</span>    <span class="n">kf</span>
    <span class="c1"># KFold(n_splits=10, random_state=None, shuffle=True)
</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">high_order</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>

    <span class="k">for</span> <span class="nb">iter</span><span class="p">,</span> <span class="p">(</span><span class="n">train_index</span><span class="p">,</span> <span class="n">test_index</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kf</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="c1"># For each split...
</span>        <span class="c1"># Now we have the indices for the training set and the test set
</span>        <span class="n">x_train</span><span class="p">,</span> <span class="n">x_test</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>
        <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>

        <span class="c1"># Plot the training set and the test set together
</span>        <span class="c1"># plt.figure()
</span>        <span class="c1"># plt.plot(x_train,y_train,'bo')
</span>        <span class="c1"># plt.plot(x_test,y_test,'rx')
</span>        <span class="c1"># plt.xlabel('x'); plt.ylabel('y')
</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">high_order</span><span class="p">):</span>
            <span class="c1"># For each polynomial order...
</span>            <span class="c1"># Train the model based on the training set and create a polynomial function
</span>            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">,</span> <span class="n">order</span> <span class="p">)</span>
            <span class="n">polyFn</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>

            <span class="n">title_str</span> <span class="o">=</span> <span class="s">'Polynomial (Order %d)'</span> <span class="o">%</span> <span class="n">order</span>     <span class="c1"># For book keeping
</span>
            <span class="c1"># Calculate the predictions
</span>            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">polyFn</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

            <span class="c1"># Calculate the estimated prediction error
</span>            <span class="n">thisError</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">((</span><span class="n">y_test</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Store on Results
</span>            <span class="n">results</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="nb">iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisError</span>

        <span class="n">thisResult</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Put it on the list!
</span>    <span class="n">results_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisResult</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="showing-your-results">Showing Your Results</h3>

<p>Now, all you have to do is show your results, assuming you ran everything in the ‚Äú<strong>Big Picture</strong>‚Äù section.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">result_item</span> <span class="ow">in</span> <span class="n">results_list</span><span class="p">:</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">polyOrders</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">result_item</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="s">'o-'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylim</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span><span class="mi">10000</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Polynomial Order'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PE Value'</span><span class="p">)</span>
</code></pre></div></div>
:ET